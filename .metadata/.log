!SESSION 2023-04-03 16:13:27.433 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_MX
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-03 16:13:29.185
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-03 16:14:07.303
!MESSAGE Logback config file: C:\Users\sr.sergiio\eclipse\java-2023-03\eclipse\Workspace - Java ArgPrograma\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-03 16:14:12.072
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-03 16:14:12.072
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-03 16:14:12.072
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-03 16:14:15.883
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sr.sergiio'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-04-03 16:56:01.862
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Perro {

	
	/*En nuevo proyecto crear una clase de nombre Perro, cuyos atributos son: nombre, raza,
	peso y edad. La clase tendrás un constructor que permita inicializar todos sus atributos y
	los métodos getter y setter. Además agregaremos un método adicional de nombre
	mostrarInfo que visualizará por consola todos los datos de este animal. Por último, desde
	el método main de la clase principal del proyecto usted creará un Perro de nombre “Olivia”
	de raza “Buldog Francés” que pese 1.2Kg con 1 año de edad; en la línea siguiente invocará
	el método mostrarInfo de la instancia creada anteriormente.*/
	
	
	String nombre;
	public String getNombre() {
		return nombre;
	}


	public void setNombre(String nombre) {
		this.nombre = nombre;
	}


	public String getRaza() {
		return raza;
	}


	public void setRaza(String raza) {
		this.raza = raza;
	}


	public double getPeso() {
		return peso;
	}


	public void setPeso(double peso) {
		this.peso = peso;
	}


	public int getEdad() {
		return edad;
	}


	public void setEdad(int edad) {
		this.edad = edad;
	}


	String raza;
	double peso;
	int edad;
	
	public void Perro()
	
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-03 16:56:01.863
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-03 16:56:01.863
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3348)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SESSION 2023-04-04 16:13:02.545 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_MX
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-04 16:13:04.679
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-04 16:13:31.983
!MESSAGE Logback config file: C:\Users\sr.sergiio\eclipse\java-2023-03\eclipse\Workspace - Java ArgPrograma\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-04 16:13:33.038
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-04 16:13:33.038
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-04 16:13:33.038
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-04 16:13:35.638
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sr.sergiio'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-04 18:09:03.736 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=20
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_MX
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-04 18:09:09.749
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-04 18:09:18.053
!MESSAGE Logback config file: C:\Users\sr.sergiio\eclipse\java-2023-03\eclipse\Workspace - Java ArgPrograma\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-04 18:09:18.906
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-04 18:09:18.907
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-04 18:09:18.907
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-04 18:09:20.876
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sr.sergiio'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-04 20:42:48.068 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=20
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_MX
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-04 20:42:48.755
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY org.eclipse.core.resources 4 567 2023-04-04 20:43:04.809
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2023-04-04 20:43:04.809
!MESSAGE Could not read metadata for '.org.eclipse.egit.core.cmp'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/.org.eclipse.egit.core.cmp)[567]: java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:894)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:874)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:730)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1584)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:571)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2023-04-04 20:43:04.809
!MESSAGE The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:894)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:874)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:730)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1584)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:571)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY ch.qos.logback.classic 1 0 2023-04-04 20:43:05.075
!MESSAGE Logback config file: C:\Users\sr.sergiio\OneDrive\Documentos\ArgentinaPrograma\Workspace - Java ArgPrograma\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-04 20:43:05.989
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-04 20:43:05.989
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-04 20:43:05.989
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-04 20:43:07.885
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sr.sergiio'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-05 15:17:22.242 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=20
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_MX
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-05 15:17:23.359
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-05 15:17:29.494
!MESSAGE Logback config file: C:\Users\sr.sergiio\OneDrive\Documentos\ArgentinaPrograma\Workspace - Java ArgPrograma\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-05 15:17:30.816
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-05 15:17:30.816
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-05 15:17:30.816
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-05 15:17:33.966
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sr.sergiio'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-08 01:47:47.286 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=20
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_MX
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-08 01:47:48.627
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-08 01:47:57.783
!MESSAGE Logback config file: C:\Users\sr.sergiio\OneDrive\Documentos\ArgentinaPrograma\Workspace - Java ArgPrograma\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-08 01:48:00.044
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-08 01:48:00.044
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-08 01:48:00.044
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-08 01:48:03.095
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sr.sergiio'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 17:47:50.700
!MESSAGE JavaBuilder handling CoreException
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ArgentinaPrograma/bin/GUIA1/Circulo.class)[275]: java.lang.Exception: A resource exists with a different case: '/ArgentinaPrograma/bin/GUIA1/Circulo.class'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.File.create(File.java:109)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:891)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:870)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:194)
	at org.eclipse.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:615)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:475)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:379)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:311)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:273)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:295)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:213)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:196)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:289)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.core.resources 4 275 2023-04-08 17:47:50.701
!MESSAGE A resource exists with a different case: '/ArgentinaPrograma/bin/GUIA1/Circulo.class'.
!STACK 0
java.lang.Exception: A resource exists with a different case: '/ArgentinaPrograma/bin/GUIA1/Circulo.class'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.File.create(File.java:109)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:891)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:870)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:194)
	at org.eclipse.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:615)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:475)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:379)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:311)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:273)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:295)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:213)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:196)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:289)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 17:47:54.596
!MESSAGE JavaBuilder handling CoreException
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ArgentinaPrograma/bin/GUIA1/Circulo.class)[275]: java.lang.Exception: A resource exists with a different case: '/ArgentinaPrograma/bin/GUIA1/Circulo.class'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.File.create(File.java:109)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:891)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:870)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:194)
	at org.eclipse.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:615)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:475)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:379)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:311)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:273)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:295)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:213)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:196)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:289)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.core.resources 4 275 2023-04-08 17:47:54.597
!MESSAGE A resource exists with a different case: '/ArgentinaPrograma/bin/GUIA1/Circulo.class'.
!STACK 0
java.lang.Exception: A resource exists with a different case: '/ArgentinaPrograma/bin/GUIA1/Circulo.class'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.File.create(File.java:109)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:891)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:870)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:194)
	at org.eclipse.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:615)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:475)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:379)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:311)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:273)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:295)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:213)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:196)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:289)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 17:47:58.340
!MESSAGE JavaBuilder handling CoreException
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ArgentinaPrograma/bin/GUIA1/Circulo.class)[275]: java.lang.Exception: A resource exists with a different case: '/ArgentinaPrograma/bin/GUIA1/Circulo.class'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.File.create(File.java:109)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:891)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:870)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:194)
	at org.eclipse.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:615)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:475)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:379)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:311)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:273)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:295)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:213)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:196)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:289)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.core.resources 4 275 2023-04-08 17:47:58.340
!MESSAGE A resource exists with a different case: '/ArgentinaPrograma/bin/GUIA1/Circulo.class'.
!STACK 0
java.lang.Exception: A resource exists with a different case: '/ArgentinaPrograma/bin/GUIA1/Circulo.class'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.File.create(File.java:109)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:891)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:870)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:194)
	at org.eclipse.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:615)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:475)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:379)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:311)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:273)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:295)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:213)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:196)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:289)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-04-08 18:42:17.471 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=20
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_MX
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-08 18:42:18.592
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-08 18:42:22.945
!MESSAGE Logback config file: C:\Users\sr.sergiio\OneDrive\Documentos\ArgentinaPrograma\Workspace - Java ArgPrograma\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-08 18:42:24.881
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-08 18:42:24.881
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-08 18:42:24.881
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-08 18:42:27.714
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sr.sergiio'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 21:40:03.834
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int i=0;i<tamano;i++) {
			 for (int j=0;j<tamano;j++) {
				 if((i>0 || i=tamaño-1)
				 System.out.print("*");
				 
			 }
			 System.out.println("");
			 
		 }
			 
		 }
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-08 21:40:03.835
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-08 21:40:03.836
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 21:40:03.844
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int i=0;i<tamano;i++) {
			 for (int j=0;j<tamano;j++) {
				 if((i>0 || i=tamaño-1)
				 System.out.print("*");
				 
			 }
			 System.out.println("");
			 
		 }
			 
		 }
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-08 21:40:03.849
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-08 21:40:03.849
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 21:40:04.363
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int i=0;i<tamano;i++) {
			 for (int j=0;j<tamano;j++) {
				 if((i>0 || i=tamaño-1)
				 System.out.print("*");
				 
			 }
			 System.out.println("");
			 
		 }
			 
		 }
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-08 21:40:04.364
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-08 21:40:04.365
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 21:40:05.683
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int i=0;i<tamano;i++) {
			 for (int j=0;j<tamano;j++) {
				 if((i>0 || i=tamaño-1)
				 System.out.print("*");
				 
			 }
			 System.out.println("");
			 
		 }
			 
		 }
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-08 21:40:05.684
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-08 21:40:05.685
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 21:40:07.278
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int i=0;i<tamano;i++) {
			 for (int j=0;j<tamano;j++) {
				 if((i>0 || i=tamaño-1 )
				 System.out.print("*");
				 
			 }
			 System.out.println("");
			 
		 }
			 
		 }
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-08 21:40:07.279
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-08 21:40:07.279
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 21:40:07.463
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int i=0;i<tamano;i++) {
			 for (int j=0;j<tamano;j++) {
				 if((i>0 || i=tamaño-1 )
				 System.out.print("*");
				 
			 }
			 System.out.println("");
			 
		 }
			 
		 }
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-08 21:40:07.464
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-08 21:40:07.464
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 21:40:09.183
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int i=0;i<tamano;i++) {
			 for (int j=0;j<tamano;j++) {
				 if((i>0 || i=tamaño-1 )
				 System.out.print("*");
				 
			 }
			 System.out.println("");
			 
		 }
			 
		 }
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-08 21:40:09.184
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-08 21:40:09.184
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 21:40:10.841
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int i=0;i<tamano;i++) {
			 for (int j=0;j<tamano;j++) {
				 if((i>0 || i=tamaño-1 )
				 System.out.print("*");
				 
			 }
			 System.out.println("");
			 
		 }
			 
		 }
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-08 21:40:10.842
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-08 21:40:10.842
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 21:40:11.554
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int i=0;i<tamano;i++) {
			 for (int j=0;j<tamano;j++) {
				 if((i>0 || i=tamaño-1)
				 System.out.print("*");
				 
			 }
			 System.out.println("");
			 
		 }
			 
		 }
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-08 21:40:11.554
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-08 21:40:11.555
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-08 21:40:11.664
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int i=0;i<tamano;i++) {
			 for (int j=0;j<tamano;j++) {
				 if((i>0 || i=tamaño-1)
				 System.out.print("*");
				 
			 }
			 System.out.println("");
			 
		 }
			 
		 }
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-08 21:40:11.665
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-08 21:40:11.665
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2718)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2267)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3063)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-09 02:12:33.865
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		Utilitario.dibujaCuadrado(8);
		System.out.println(Utilitario.elMayorEs(4, 1, 2) );
		Utilitario.elDiaEs(2);
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int y=0;y<tamano;y++) {
			 for (int x=0;x<tamano;x++) {
				 if(!((y<tamano-1 && y>0) && (x<tamano-1 && x>0)))  
					 System.out.print("*") ;
				 else {
					 System.out.print(" ") ;
					 } 
			 }
			 System.out.println(" ");
			 
		 }
			 
	}
	 
	 public static int elMayorEs(int numeroUno,int numeroDos,int numeroTres) {
		  int NumeroMayor = numeroUno>=numeroDos && numeroUno>=numeroTres? numeroUno:(numeroDos>=numeroUno && numeroDos>=numeroTres)? numeroDos:numeroTres;
		  return NumeroMayor;
		 }
	 public static void elDiaEs(int dia) {

		 System.out.println((dia==1)? "Lunes":(dia==2)? "Martes":(dia==3)? "Miercoles":(dia==4)? "Jueves":(dia==5)? "Viernes":(dia==6)? "Sabado":"Domingo");
	 }
	 
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-09 02:12:33.870
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-09 02:12:33.870
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-09 02:12:34.182
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		Utilitario.dibujaCuadrado(8);
		System.out.println(Utilitario.elMayorEs(4, 1, 2) );
		Utilitario.elDiaEs(2);
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int y=0;y<tamano;y++) {
			 for (int x=0;x<tamano;x++) {
				 if(!((y<tamano-1 && y>0) && (x<tamano-1 && x>0)))  
					 System.out.print("*") ;
				 else {
					 System.out.print(" ") ;
					 } 
			 }
			 System.out.println(" ");
			 
		 }
			 
	}
	 
	 public static int elMayorEs(int numeroUno,int numeroDos,int numeroTres) {
		  int NumeroMayor = numeroUno>=numeroDos && numeroUno>=numeroTres? numeroUno:(numeroDos>=numeroUno && numeroDos>=numeroTres)? numeroDos:numeroTres;
		  return NumeroMayor;
		 }
	 public static void elDiaEs(int dia) {

		 System.out.println((dia==1)? "Lunes":(dia==2)? "Martes":(dia==3)? "Miercoles":(dia==4)? "Jueves":(dia==5)? "Viernes":(dia==6)? "Sabado":"Domingo");
	 }
	 
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-09 02:12:34.183
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-09 02:12:34.183
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-09 02:12:35.024
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		Utilitario.dibujaCuadrado(8);
		System.out.println(Utilitario.elMayorEs(4, 1, 2) );
		Utilitario.elDiaEs(2);
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int y=0;y<tamano;y++) {
			 for (int x=0;x<tamano;x++) {
				 if(!((y<tamano-1 && y>0) && (x<tamano-1 && x>0)))  
					 System.out.print("*") ;
				 else {
					 System.out.print(" ") ;
					 } 
			 }
			 System.out.println(" ");
			 
		 }
			 
	}
	 
	 public static int elMayorEs(int numeroUno,int numeroDos,int numeroTres) {
		  int NumeroMayor = numeroUno>=numeroDos && numeroUno>=numeroTres? numeroUno:(numeroDos>=numeroUno && numeroDos>=numeroTres)? numeroDos:numeroTres;
		  return NumeroMayor;
		 }
	 public static void elDiaEs(int dia) {

		 System.out.println((dia==1)? "Lunes":(dia==2)? "Martes":(dia==3)? "Miercoles":(dia==4)? "Jueves":(dia==5)? "Viernes":(dia==6)? "Sabado":"Domingo");
	 }
	 
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-09 02:12:35.025
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-09 02:12:35.025
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-09 02:12:35.919
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\n\n//////////////////////////////////Numero//////////////////////////////\n\n");
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		
		System.out.println("\n\n/////////////////////////////circuloUno///////////////////////////////////\n\n");
		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		

		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		Utilitario.dibujaCuadrado(8);
		System.out.println(Utilitario.elMayorEs(4, 1, 2) );
		Utilitario.elDiaEs(2);
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}
	

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int y=0;y<tamano;y++) {
			 for (int x=0;x<tamano;x++) {
				 if(!((y<tamano-1 && y>0) && (x<tamano-1 && x>0)))  
					 System.out.print("*") ;
				 else {
					 System.out.print(" ") ;
					 } 
			 }
			 System.out.println(" ");
			 
		 }
			 
	}
	 
	 public static int elMayorEs(int numeroUno,int numeroDos,int numeroTres) {
		  int NumeroMayor = numeroUno>=numeroDos && numeroUno>=numeroTres? numeroUno:(numeroDos>=numeroUno && numeroDos>=numeroTres)? numeroDos:numeroTres;
		  return NumeroMayor;
		 }
	 public static void elDiaEs(int dia) {

		 System.out.println((dia==1)? "Lunes":(dia==2)? "Martes":(dia==3)? "Miercoles":(dia==4)? "Jueves":(dia==5)? "Viernes":(dia==6)? "Sabado":"Domingo");
	 }
	 
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false.  tipoTriangulo(): Si es un triángulo y
		 * tiene sus tres lados iguales, este método retornará equilátero; si sus tres
		 * lados son distintos, retornará “escaleno”; caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: a) Crear un objeto Triángulo válido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * b) Mostrar por consola que tipo de triángulo es. c) Crear un objeto Triángulo
		 * inválido.
		 * 
		 * Luego utilizando sus métodos:
		 * 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 
	 
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía y nombre; un constructor que
		 * permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. Luego desde la clase principal del proyecto (la que contiene el método
		 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-09 02:12:35.920
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-09 02:12:35.920
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 01:23:47.942
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*Numero*/
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		/*circuloUno*/		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * Utilizando los métodos estáticos de Utilitario: 
		 * a) Dibujar un cuadrado de 5 elementos. 
		 * b) Mostrar el mayor entre (20,75 y 40) 
		 * c) Mostrar el nombre del día 5.
		 */
		Utilitario.dibujaCuadrado(5);
		System.out.println(Utilitario.elMayorEs(20, 75, 40) );
		Utilitario.elDiaEs(5);
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * a) Crear un objeto Triángulo válido. Luego utilizando sus métodos: 
		 * b) Mostrar por consola que tipo de triángulo es. 
		 * c) Crear un objeto Triángulo inválido.Luego utilizando sus métodos: 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
		Triangulo t1 = new Triangulo(2,2,2);
		System.out.println(t1.tipoTriangulo());
		Triangulo t2 = new Triangulo(0,2,2);
		System.out.println(t2.tipoTriangulo());
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		Luego desde la clase principal del proyecto (la que contiene el método
				 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
				 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int y=0;y<tamano;y++) {
			 for (int x=0;x<tamano;x++) {
				 if(!((y<tamano-1 && y>0) && (x<tamano-1 && x>0)))  
					 System.out.print("*") ;
				 else {
					 System.out.print(" ") ;
					 } 
			 }
			 System.out.println(" ");
			 
		 }
			 
	}
	 
	 public static int elMayorEs(int numeroUno,int numeroDos,int numeroTres) {
		  int NumeroMayor = numeroUno>=numeroDos && numeroUno>=numeroTres? numeroUno:(numeroDos>=numeroUno && numeroDos>=numeroTres)? numeroDos:numeroTres;
		  return NumeroMayor;
		 }
	 public static void elDiaEs(int dia) {

		 System.out.println((dia==1)? "Lunes":(dia==2)? "Martes":(dia==3)? "Miercoles":(dia==4)? "Jueves":(dia==5)? "Viernes":(dia==6)? "Sabado":"Domingo");
	 }
	 
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false. 
		 *  tipoTriangulo(): Si es un triángulo y tiene sus tres lados iguales, este método retornará equilátero; 
		 * si sus tres
		 * lados son distintos, retornará “escaleno”; 
		 * caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; 
		 * en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: 
		 * 
		 * a) Crear un objeto Triángulo válido. Luego utilizando sus métodos:
		 * b) Mostrar por consola que tipo de triángulo es. 
		 * c) Crear un objeto Triángulo inválido.Luego utilizando sus métodos:
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 private int lado1,lado2,lado3;
	 
	public Triangulo(int lado1 ,int lado2,int lado3) {
		this.lado1=lado1;
		this.lado2=lado2;
		this.lado3=lado3;
	}
	 
	public int getLado1() {
		return lado1;
	}
	public void setLado1(int lado1) {
		this.lado1 = lado1;
	}
	public int getLado2() {
		return lado2;
	}
	public void setLado2(int lado2) {
		this.lado2 = lado2;
	}
	public int getLado3() {
		return lado3;
	}
	public void setLado3(int lado3) {
		this.lado3 = lado3;
	}
	 
	public boolean esUnTriangulo(){
		boolean esUnTriangulo=false;
		if ( this.getLado1()>=this.getLado2() && this.getLado1()>=this.getLado3()) {
			esUnTriangulo= this.getLado1()>this.getLado2()+this.getLado3();
		}
		if ( this.getLado2()>=this.getLado1() && this.getLado2()>=this.getLado3()) {
			esUnTriangulo= this.getLado2()>this.getLado1()+this.getLado3();
		}
		if ( this.getLado3()>=this.getLado1() && this.getLado3()>=this.getLado2()) {
			esUnTriangulo= this.getLado3()>this.getLado1()+this.getLado2();
		}
		return esUnTriangulo;
	}
	public String tipoTriangulo(){
		String tipoTriangulo="";
		if (this.getLado1()==0 || this.getLado2()==0 || this.getLado3()==0) {
			tipoTriangulo="NO ES TRIANGULO";
		}else {
		
		if(this.getLado1()==this.getLado2() && this.getLado1()==this.getLado3()  ) {
			tipoTriangulo="equilatero";
		}
		if(this.getLado1()!=this.getLado2() && this.getLado1()!=this.getLado3() && this.getLado2()!=this.getLado3()  ) {
			tipoTriangulo="escaleno";
		}
		if((this.getLado1()==this.getLado2() && this.getLado1()!=this.getLado3()) || (this.getLado1()==this.getLado3() && this.getLado1()!=this.getLado2()) || (this.getLado2()==this.getLado3() && this.getLado2()!=this.getLado1()) ) {
			tipoTriangulo="isósceles";
		}}
		return tipoTriangulo;
		
	}
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía 
		 *  y nombre; 
		 *  un constructor que permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. 
		 */
	 private double bateria = 500;
	 public double getBateria() {
		return bateria;
	}

	public void setBateria(double bateria) {
		this.bateria = bateria;
	}

	private String Nombre ;
	 
	 public Robot(String nombre) {
		 this.Nombre=nombre;
		 this.bateria=bateria;
	 }
	 public void avanzar(int pasos) {
		 if (this.getBateria()-(100/10*pasos)<0) {
			 this.setBateria(this.getBateria()-(100/10*pasos));
		 }
		 	System.out.println("No hay suficiente bareria");
	 }
	 
	 public boolean bateriaVacia() {
		 return this.getBateria()<=0;
	 }
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-10 01:23:47.947
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-10 01:23:47.947
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 01:23:47.960
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*Numero*/
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		/*circuloUno*/		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * Utilizando los métodos estáticos de Utilitario: 
		 * a) Dibujar un cuadrado de 5 elementos. 
		 * b) Mostrar el mayor entre (20,75 y 40) 
		 * c) Mostrar el nombre del día 5.
		 */
		Utilitario.dibujaCuadrado(5);
		System.out.println(Utilitario.elMayorEs(20, 75, 40) );
		Utilitario.elDiaEs(5);
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * a) Crear un objeto Triángulo válido. Luego utilizando sus métodos: 
		 * b) Mostrar por consola que tipo de triángulo es. 
		 * c) Crear un objeto Triángulo inválido.Luego utilizando sus métodos: 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
		Triangulo t1 = new Triangulo(2,2,2);
		System.out.println(t1.tipoTriangulo());
		Triangulo t2 = new Triangulo(0,2,2);
		System.out.println(t2.tipoTriangulo());
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		Luego desde la clase principal del proyecto (la que contiene el método
				 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
				 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int y=0;y<tamano;y++) {
			 for (int x=0;x<tamano;x++) {
				 if(!((y<tamano-1 && y>0) && (x<tamano-1 && x>0)))  
					 System.out.print("*") ;
				 else {
					 System.out.print(" ") ;
					 } 
			 }
			 System.out.println(" ");
			 
		 }
			 
	}
	 
	 public static int elMayorEs(int numeroUno,int numeroDos,int numeroTres) {
		  int NumeroMayor = numeroUno>=numeroDos && numeroUno>=numeroTres? numeroUno:(numeroDos>=numeroUno && numeroDos>=numeroTres)? numeroDos:numeroTres;
		  return NumeroMayor;
		 }
	 public static void elDiaEs(int dia) {

		 System.out.println((dia==1)? "Lunes":(dia==2)? "Martes":(dia==3)? "Miercoles":(dia==4)? "Jueves":(dia==5)? "Viernes":(dia==6)? "Sabado":"Domingo");
	 }
	 
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false. 
		 *  tipoTriangulo(): Si es un triángulo y tiene sus tres lados iguales, este método retornará equilátero; 
		 * si sus tres
		 * lados son distintos, retornará “escaleno”; 
		 * caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; 
		 * en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: 
		 * 
		 * a) Crear un objeto Triángulo válido. Luego utilizando sus métodos:
		 * b) Mostrar por consola que tipo de triángulo es. 
		 * c) Crear un objeto Triángulo inválido.Luego utilizando sus métodos:
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 private int lado1,lado2,lado3;
	 
	public Triangulo(int lado1 ,int lado2,int lado3) {
		this.lado1=lado1;
		this.lado2=lado2;
		this.lado3=lado3;
	}
	 
	public int getLado1() {
		return lado1;
	}
	public void setLado1(int lado1) {
		this.lado1 = lado1;
	}
	public int getLado2() {
		return lado2;
	}
	public void setLado2(int lado2) {
		this.lado2 = lado2;
	}
	public int getLado3() {
		return lado3;
	}
	public void setLado3(int lado3) {
		this.lado3 = lado3;
	}
	 
	public boolean esUnTriangulo(){
		boolean esUnTriangulo=false;
		if ( this.getLado1()>=this.getLado2() && this.getLado1()>=this.getLado3()) {
			esUnTriangulo= this.getLado1()>this.getLado2()+this.getLado3();
		}
		if ( this.getLado2()>=this.getLado1() && this.getLado2()>=this.getLado3()) {
			esUnTriangulo= this.getLado2()>this.getLado1()+this.getLado3();
		}
		if ( this.getLado3()>=this.getLado1() && this.getLado3()>=this.getLado2()) {
			esUnTriangulo= this.getLado3()>this.getLado1()+this.getLado2();
		}
		return esUnTriangulo;
	}
	public String tipoTriangulo(){
		String tipoTriangulo="";
		if (this.getLado1()==0 || this.getLado2()==0 || this.getLado3()==0) {
			tipoTriangulo="NO ES TRIANGULO";
		}else {
		
		if(this.getLado1()==this.getLado2() && this.getLado1()==this.getLado3()  ) {
			tipoTriangulo="equilatero";
		}
		if(this.getLado1()!=this.getLado2() && this.getLado1()!=this.getLado3() && this.getLado2()!=this.getLado3()  ) {
			tipoTriangulo="escaleno";
		}
		if((this.getLado1()==this.getLado2() && this.getLado1()!=this.getLado3()) || (this.getLado1()==this.getLado3() && this.getLado1()!=this.getLado2()) || (this.getLado2()==this.getLado3() && this.getLado2()!=this.getLado1()) ) {
			tipoTriangulo="isósceles";
		}}
		return tipoTriangulo;
		
	}
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía 
		 *  y nombre; 
		 *  un constructor que permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. 
		 */
	 private double bateria = 500;
	 public double getBateria() {
		return bateria;
	}

	public void setBateria(double bateria) {
		this.bateria = bateria;
	}

	private String Nombre ;
	 
	 public Robot(String nombre) {
		 this.Nombre=nombre;
		 this.bateria=bateria;
	 }
	 public void avanzar(int pasos) {
		 if (this.getBateria()-(100/10*pasos)<0) {
			 this.setBateria(this.getBateria()-(100/10*pasos));
		 }
		 	System.out.println("No hay suficiente bareria");
	 }
	 
	 public boolean bateriaVacia() {
		 return this.getBateria()<=0;
	 }
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-10 01:23:47.960
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-10 01:23:47.961
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 01:23:50.277
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*Numero*/
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		/*circuloUno*/		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * Utilizando los métodos estáticos de Utilitario: 
		 * a) Dibujar un cuadrado de 5 elementos. 
		 * b) Mostrar el mayor entre (20,75 y 40) 
		 * c) Mostrar el nombre del día 5.
		 */
		Utilitario.dibujaCuadrado(5);
		System.out.println(Utilitario.elMayorEs(20, 75, 40) );
		Utilitario.elDiaEs(5);
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * a) Crear un objeto Triángulo válido. Luego utilizando sus métodos: 
		 * b) Mostrar por consola que tipo de triángulo es. 
		 * c) Crear un objeto Triángulo inválido.Luego utilizando sus métodos: 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
		Triangulo t1 = new Triangulo(2,2,2);
		System.out.println(t1.tipoTriangulo());
		Triangulo t2 = new Triangulo(0,2,2);
		System.out.println(t2.tipoTriangulo());
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		Luego desde la clase principal del proyecto (la que contiene el método
				 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
				 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int y=0;y<tamano;y++) {
			 for (int x=0;x<tamano;x++) {
				 if(!((y<tamano-1 && y>0) && (x<tamano-1 && x>0)))  
					 System.out.print("*") ;
				 else {
					 System.out.print(" ") ;
					 } 
			 }
			 System.out.println(" ");
			 
		 }
			 
	}
	 
	 public static int elMayorEs(int numeroUno,int numeroDos,int numeroTres) {
		  int NumeroMayor = numeroUno>=numeroDos && numeroUno>=numeroTres? numeroUno:(numeroDos>=numeroUno && numeroDos>=numeroTres)? numeroDos:numeroTres;
		  return NumeroMayor;
		 }
	 public static void elDiaEs(int dia) {

		 System.out.println((dia==1)? "Lunes":(dia==2)? "Martes":(dia==3)? "Miercoles":(dia==4)? "Jueves":(dia==5)? "Viernes":(dia==6)? "Sabado":"Domingo");
	 }
	 
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false. 
		 *  tipoTriangulo(): Si es un triángulo y tiene sus tres lados iguales, este método retornará equilátero; 
		 * si sus tres
		 * lados son distintos, retornará “escaleno”; 
		 * caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; 
		 * en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: 
		 * 
		 * a) Crear un objeto Triángulo válido. Luego utilizando sus métodos:
		 * b) Mostrar por consola que tipo de triángulo es. 
		 * c) Crear un objeto Triángulo inválido.Luego utilizando sus métodos:
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 private int lado1,lado2,lado3;
	 
	public Triangulo(int lado1 ,int lado2,int lado3) {
		this.lado1=lado1;
		this.lado2=lado2;
		this.lado3=lado3;
	}
	 
	public int getLado1() {
		return lado1;
	}
	public void setLado1(int lado1) {
		this.lado1 = lado1;
	}
	public int getLado2() {
		return lado2;
	}
	public void setLado2(int lado2) {
		this.lado2 = lado2;
	}
	public int getLado3() {
		return lado3;
	}
	public void setLado3(int lado3) {
		this.lado3 = lado3;
	}
	 
	public boolean esUnTriangulo(){
		boolean esUnTriangulo=false;
		if ( this.getLado1()>=this.getLado2() && this.getLado1()>=this.getLado3()) {
			esUnTriangulo= this.getLado1()>this.getLado2()+this.getLado3();
		}
		if ( this.getLado2()>=this.getLado1() && this.getLado2()>=this.getLado3()) {
			esUnTriangulo= this.getLado2()>this.getLado1()+this.getLado3();
		}
		if ( this.getLado3()>=this.getLado1() && this.getLado3()>=this.getLado2()) {
			esUnTriangulo= this.getLado3()>this.getLado1()+this.getLado2();
		}
		return esUnTriangulo;
	}
	public String tipoTriangulo(){
		String tipoTriangulo="";
		if (this.getLado1()==0 || this.getLado2()==0 || this.getLado3()==0) {
			tipoTriangulo="NO ES TRIANGULO";
		}else {
		
		if(this.getLado1()==this.getLado2() && this.getLado1()==this.getLado3()  ) {
			tipoTriangulo="equilatero";
		}
		if(this.getLado1()!=this.getLado2() && this.getLado1()!=this.getLado3() && this.getLado2()!=this.getLado3()  ) {
			tipoTriangulo="escaleno";
		}
		if((this.getLado1()==this.getLado2() && this.getLado1()!=this.getLado3()) || (this.getLado1()==this.getLado3() && this.getLado1()!=this.getLado2()) || (this.getLado2()==this.getLado3() && this.getLado2()!=this.getLado1()) ) {
			tipoTriangulo="isósceles";
		}}
		return tipoTriangulo;
		
	}
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía 
		 *  y nombre; 
		 *  un constructor que permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. 
		 */
	 private double bateria = 500;
	 public double getBateria() {
		return bateria;
	}

	public void setBateria(double bateria) {
		this.bateria = bateria;
	}

	private String Nombre ;
	 
	 public Robot(String nombre) {
		 this.Nombre=nombre;
		 this.bateria=bateria;
	 }
	 public void avanzar(int pasos) {
		 if (this.getBateria()-(100/10*pasos)<0) {
			 this.setBateria(this.getBateria()-(100/10*pasos));
		 }
		 	System.out.println("No hay suficiente bareria");
	 }
	 
	 public boolean bateriaVacia() {
		 return this.getBateria()<=0;
	 }
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-10 01:23:50.278
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-10 01:23:50.278
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 01:24:10.533
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*Numero*/
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		/*circuloUno*/		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * Utilizando los métodos estáticos de Utilitario: 
		 * a) Dibujar un cuadrado de 5 elementos. 
		 * b) Mostrar el mayor entre (20,75 y 40) 
		 * c) Mostrar el nombre del día 5.
		 */
		Utilitario.dibujaCuadrado(5);
		System.out.println(Utilitario.elMayorEs(20, 75, 40) );
		Utilitario.elDiaEs(5);
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * a) Crear un objeto Triángulo válido. Luego utilizando sus métodos: 
		 * b) Mostrar por consola que tipo de triángulo es. 
		 * c) Crear un objeto Triángulo inválido.Luego utilizando sus métodos: 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
		Triangulo t1 = new Triangulo(2,2,2);
		System.out.println(t1.tipoTriangulo());
		Triangulo t2 = new Triangulo(0,2,2);
		System.out.println(t2.tipoTriangulo());
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * Luego desde la clase principal del proyecto (la que contiene el método main)
		 * se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
		Robot et = new Luego desde la clase principal del proyecto (la que contiene el método
				 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
				 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int y=0;y<tamano;y++) {
			 for (int x=0;x<tamano;x++) {
				 if(!((y<tamano-1 && y>0) && (x<tamano-1 && x>0)))  
					 System.out.print("*") ;
				 else {
					 System.out.print(" ") ;
					 } 
			 }
			 System.out.println(" ");
			 
		 }
			 
	}
	 
	 public static int elMayorEs(int numeroUno,int numeroDos,int numeroTres) {
		  int NumeroMayor = numeroUno>=numeroDos && numeroUno>=numeroTres? numeroUno:(numeroDos>=numeroUno && numeroDos>=numeroTres)? numeroDos:numeroTres;
		  return NumeroMayor;
		 }
	 public static void elDiaEs(int dia) {

		 System.out.println((dia==1)? "Lunes":(dia==2)? "Martes":(dia==3)? "Miercoles":(dia==4)? "Jueves":(dia==5)? "Viernes":(dia==6)? "Sabado":"Domingo");
	 }
	 
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false. 
		 *  tipoTriangulo(): Si es un triángulo y tiene sus tres lados iguales, este método retornará equilátero; 
		 * si sus tres
		 * lados son distintos, retornará “escaleno”; 
		 * caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; 
		 * en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: 
		 * 
		 * a) Crear un objeto Triángulo válido. Luego utilizando sus métodos:
		 * b) Mostrar por consola que tipo de triángulo es. 
		 * c) Crear un objeto Triángulo inválido.Luego utilizando sus métodos:
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 private int lado1,lado2,lado3;
	 
	public Triangulo(int lado1 ,int lado2,int lado3) {
		this.lado1=lado1;
		this.lado2=lado2;
		this.lado3=lado3;
	}
	 
	public int getLado1() {
		return lado1;
	}
	public void setLado1(int lado1) {
		this.lado1 = lado1;
	}
	public int getLado2() {
		return lado2;
	}
	public void setLado2(int lado2) {
		this.lado2 = lado2;
	}
	public int getLado3() {
		return lado3;
	}
	public void setLado3(int lado3) {
		this.lado3 = lado3;
	}
	 
	public boolean esUnTriangulo(){
		boolean esUnTriangulo=false;
		if ( this.getLado1()>=this.getLado2() && this.getLado1()>=this.getLado3()) {
			esUnTriangulo= this.getLado1()>this.getLado2()+this.getLado3();
		}
		if ( this.getLado2()>=this.getLado1() && this.getLado2()>=this.getLado3()) {
			esUnTriangulo= this.getLado2()>this.getLado1()+this.getLado3();
		}
		if ( this.getLado3()>=this.getLado1() && this.getLado3()>=this.getLado2()) {
			esUnTriangulo= this.getLado3()>this.getLado1()+this.getLado2();
		}
		return esUnTriangulo;
	}
	public String tipoTriangulo(){
		String tipoTriangulo="";
		if (this.getLado1()==0 || this.getLado2()==0 || this.getLado3()==0) {
			tipoTriangulo="NO ES TRIANGULO";
		}else {
		
		if(this.getLado1()==this.getLado2() && this.getLado1()==this.getLado3()  ) {
			tipoTriangulo="equilatero";
		}
		if(this.getLado1()!=this.getLado2() && this.getLado1()!=this.getLado3() && this.getLado2()!=this.getLado3()  ) {
			tipoTriangulo="escaleno";
		}
		if((this.getLado1()==this.getLado2() && this.getLado1()!=this.getLado3()) || (this.getLado1()==this.getLado3() && this.getLado1()!=this.getLado2()) || (this.getLado2()==this.getLado3() && this.getLado2()!=this.getLado1()) ) {
			tipoTriangulo="isósceles";
		}}
		return tipoTriangulo;
		
	}
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía 
		 *  y nombre; 
		 *  un constructor que permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. 
		 */
	 private double bateria = 500;
	 public double getBateria() {
		return bateria;
	}

	public void setBateria(double bateria) {
		this.bateria = bateria;
	}

	private String Nombre ;
	 
	 public Robot(String nombre) {
		 this.Nombre=nombre;
		 this.bateria=bateria;
	 }
	 public void avanzar(int pasos) {
		 if (this.getBateria()-(100/10*pasos)<0) {
			 this.setBateria(this.getBateria()-(100/10*pasos));
		 }
		 	System.out.println("No hay suficiente bareria");
	 }
	 
	 public boolean bateriaVacia() {
		 return this.getBateria()<=0;
	 }
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-10 01:24:10.534
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-10 01:24:10.534
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 01:24:10.734
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GUIA1;

public class Encuentro4_10 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*Numero*/
		Numero num = new Numero(2);
		System.out.println("numero 2  es multiplo de 2 : "+num.esMultiploDe(2));
		System.out.println("numero 2  es multiplo de 8 : "+num.esMultiploDe(7));
		System.out.println("\n\n//////////////////////////////////Cuadrilatero//////////////////////////////\n\n");
		Cuadrilatero cuaUno= new Cuadrilatero(70,50);
		System.out.println("\n a) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto() 
				+" \n b) su perimetro : "+cuaUno.calcularPerimetro()
				+" \n c) su superficie :"+cuaUno.calcularArea()+" \n d) si es un cuadrado o no : "+cuaUno.esUnCuadrado());
		cuaUno.setAlto(70);
		System.out.println("\n e) largo : "+cuaUno.getLargo() +" Alto :" +cuaUno.getAlto()  
				+"\n es un cuadrado :"+cuaUno.esUnCuadrado() );
		/*circuloUno*/		
		Circulo circuloUno = new Circulo(5.75);
		System.out.println("Area de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularArea());
		System.out.println("Perimetro de un ciruculo : de radio "+circuloUno.getRadio()+" es igual "+circuloUno.calcularPerímetro());
		System.out.println("\n\n/////////////////////////////ClASS CONVERSOR///////////////////////////////////\n\n");
			 System.out.println("500 USD a PESOS = "+Conversor.convertirAPesos(500));
			 System.out.println("25700 PESOS a USD = "+Conversor.convertirADolar(25700));
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * Utilizando los métodos estáticos de Utilitario: 
		 * a) Dibujar un cuadrado de 5 elementos. 
		 * b) Mostrar el mayor entre (20,75 y 40) 
		 * c) Mostrar el nombre del día 5.
		 */
		Utilitario.dibujaCuadrado(5);
		System.out.println(Utilitario.elMayorEs(20, 75, 40) );
		Utilitario.elDiaEs(5);
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * a) Crear un objeto Triángulo válido. Luego utilizando sus métodos: 
		 * b) Mostrar por consola que tipo de triángulo es. 
		 * c) Crear un objeto Triángulo inválido.Luego utilizando sus métodos: 
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
		Triangulo t1 = new Triangulo(2,2,2);
		System.out.println(t1.tipoTriangulo());
		Triangulo t2 = new Triangulo(0,2,2);
		System.out.println(t2.tipoTriangulo());
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		/*
		 * Luego desde la clase principal del proyecto (la que contiene el método main)
		 * se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
		 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		 */
		Robot et = new Luego desde la clase principal del proyecto (la que contiene el método
				 * main) se pide: a) Crear un objeto Robot de nombre “Tito” Luego utilizando sus
				 * métodos: b) Hacerlo avanzar de a un paso hasta que se quede sin batería.
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
		
		System.out.println("\n\n////////////////////////////////////////////////////////////////\n\n");
		
	}
}
class Numero {
	private int numero ;
	
	public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public Numero() {
		
	}
	
	public Numero(int num) {
		this.numero=num;
	}
	
	public boolean esPar(int Numero) {
		return Numero%2==0;
	}
	
	public boolean esPositivo(int Numero) {
		return Numero>0;
	}
	
	public boolean esMultiploDe(int Numero) {
	boolean  resultado =false;
		if (this.getNumero()<=Numero) {
			for (int i=1 ;i<Numero;i++) {
				resultado= this.getNumero()*i==Numero;
				if (resultado==true)break;
				
			}
		}
		
		return resultado;
	}

}


class Cuadrilatero {
	private double largo ,alto ;
	
	public double getLargo() {
		return largo;
	}

	public void setLargo(double largo) {
		this.largo = largo;
	}

	public double getAlto() {
		return alto;
	}

	public void setAlto(double alto) {
		this.alto = alto;
	}

	public Cuadrilatero() {
		
	}
	
	public Cuadrilatero(double largo ,double alto) {
		this.largo = largo;
		this.alto = alto;
		
	}
	
	public double	calcularPerimetro(){
		return this.getLargo() *this.getLargo()*2;
	}
	
	public double calcularArea() {
		return this.getLargo() *this.getLargo();
	}
	
	public Boolean esUnCuadrado() {
		return this.getLargo() ==this.getAlto();
	}
	
}

 class Circulo{
	
	private double pi= Math.PI;
	private double radio;
	
	public double getRadio() {
		return radio;
	}

	public void setRadio(double radio) {
		this.radio = radio;
	}

	public Circulo() {
		
	}
	
	public Circulo(double radio) {
		this.radio=radio;
	}
	
	public  double calcularArea() {
		return this.pi*Math.pow(this.getRadio(), 2);
	}
	
	public double  calcularPerímetro(){
		return 2*this.pi *this.getRadio();
	}
	
}
 
 class Conversor{
	 
		/*
		 * 4) En un nuevo proyecto, crear una clase de nombre Conversor con los
		 * siguientes métodos estáticos:  convertirAPesos(): recibe un valor en dólares
		 * y retorna convertido a pesos argentinos.  convertirADolar(): recibe un valor
		 * en pesos argentinos y retorna convertido a dólar. Luego desde la clase
		 * principal del proyecto (la que contiene el método main) se pide: Utilizando
		 * los métodos estáticos de la clase Conversor. a) Convertir 500 dólares a pesos
		 * y mostrar por consola lo convertido. b) Convertir 25700 pesos a dólares y
		 * mostrar por consola lo convertido.
		 */
	 
	 public static  double convertirAPesos( double dolar) {
		 return dolar*390;
	 }
	 
	 public static  double convertirADolar( double Pesos) {
		 return Pesos/390;
	 }
 }
 
 class Utilitario{
	 
		/*
		 * En un nuevo proyecto, crear una clase de nombre Utilitario con una serie de
		 * métodos estáticos:  dibujaCuadrado(): Este método recibe un número entero N,
		 * y dibujará un cuadrado de N elementos por lado utilizando el carácter “*”.
		 * Por ejemplo, si el cuadrado tiene 4 elementos por lado se deberá dibujar lo
		 * siguiente:
		 * 
		 * * * * * * * * *
		 * 
		 *  elMayorEs(): Este método recibe 3 números enteros y mostrará por consola
		 * cual es el mayor. En caso de ser iguales lo deberá informar.  elDiaEs(): Se
		 * espera que este método reciba un numero entero entre 1 y 7 que corresponderá
		 * a un día de la semana, retornando el nombre que le corresponda, por ejemplo:
		 * 1 Lunes, 2Martes, 3Miércoles, 4Jueves, 5Viernes, 6Sábado, 7 Domingo.
		 * Si recibe un valor distinto retornará “No existe ese día!!!”. Luego desde la
		 * clase principal del proyecto (la que contiene el método main) se pide:
		 * 
		 * Utilizando los métodos estáticos de Utilitario: a) Dibujar un cuadrado de 5
		 * elementos. b) Mostrar el mayor entre (20,75 y 40) c) Mostrar el nombre del
		 * día 5.
		 */
	 
	 public static void dibujaCuadrado(int tamano){
		 for (int y=0;y<tamano;y++) {
			 for (int x=0;x<tamano;x++) {
				 if(!((y<tamano-1 && y>0) && (x<tamano-1 && x>0)))  
					 System.out.print("*") ;
				 else {
					 System.out.print(" ") ;
					 } 
			 }
			 System.out.println(" ");
			 
		 }
			 
	}
	 
	 public static int elMayorEs(int numeroUno,int numeroDos,int numeroTres) {
		  int NumeroMayor = numeroUno>=numeroDos && numeroUno>=numeroTres? numeroUno:(numeroDos>=numeroUno && numeroDos>=numeroTres)? numeroDos:numeroTres;
		  return NumeroMayor;
		 }
	 public static void elDiaEs(int dia) {

		 System.out.println((dia==1)? "Lunes":(dia==2)? "Martes":(dia==3)? "Miercoles":(dia==4)? "Jueves":(dia==5)? "Viernes":(dia==6)? "Sabado":"Domingo");
	 }
	 
		
 }
 
 class Triangulo{
	 
		/*
		 * 6) En un nuevo proyecto, crear una clase de nombre Triangulo con los
		 * atributos: lado1, lado2, lado3; un constructor que permita inicializar sus
		 * atributos; los métodos getter y setter; y los siguientes métodos adicionales:
		 * 
		 *  esUnTriangulo(): Sabiendo que la regla principal que da origen al triángulo
		 * tiene que ver con la longitud de sus lados. Esta plantea que la suma de dos
		 * de sus lados debe ser mayor a la longitud del tercer lado. Por lo tanto si
		 * los valores de los lados de este triángulo cumplen con la regla este método
		 * retornará true caso contrario false. 
		 *  tipoTriangulo(): Si es un triángulo y tiene sus tres lados iguales, este método retornará equilátero; 
		 * si sus tres
		 * lados son distintos, retornará “escaleno”; 
		 * caso contrario, es decir, si sólo
		 * dos de sus lados son iguales, retornará “isósceles”; 
		 * en el caso de que no sea
		 * un triángulo, retornará “Con sus lados no se puede representar un
		 * triángulo!!!” Luego desde la clase principal del proyecto (la que contiene el
		 * método main) se pide: 
		 * 
		 * a) Crear un objeto Triángulo válido. Luego utilizando sus métodos:
		 * b) Mostrar por consola que tipo de triángulo es. 
		 * c) Crear un objeto Triángulo inválido.Luego utilizando sus métodos:
		 * d) Mostrar por consola que tipo de triangulo es.
		 */
	 private int lado1,lado2,lado3;
	 
	public Triangulo(int lado1 ,int lado2,int lado3) {
		this.lado1=lado1;
		this.lado2=lado2;
		this.lado3=lado3;
	}
	 
	public int getLado1() {
		return lado1;
	}
	public void setLado1(int lado1) {
		this.lado1 = lado1;
	}
	public int getLado2() {
		return lado2;
	}
	public void setLado2(int lado2) {
		this.lado2 = lado2;
	}
	public int getLado3() {
		return lado3;
	}
	public void setLado3(int lado3) {
		this.lado3 = lado3;
	}
	 
	public boolean esUnTriangulo(){
		boolean esUnTriangulo=false;
		if ( this.getLado1()>=this.getLado2() && this.getLado1()>=this.getLado3()) {
			esUnTriangulo= this.getLado1()>this.getLado2()+this.getLado3();
		}
		if ( this.getLado2()>=this.getLado1() && this.getLado2()>=this.getLado3()) {
			esUnTriangulo= this.getLado2()>this.getLado1()+this.getLado3();
		}
		if ( this.getLado3()>=this.getLado1() && this.getLado3()>=this.getLado2()) {
			esUnTriangulo= this.getLado3()>this.getLado1()+this.getLado2();
		}
		return esUnTriangulo;
	}
	public String tipoTriangulo(){
		String tipoTriangulo="";
		if (this.getLado1()==0 || this.getLado2()==0 || this.getLado3()==0) {
			tipoTriangulo="NO ES TRIANGULO";
		}else {
		
		if(this.getLado1()==this.getLado2() && this.getLado1()==this.getLado3()  ) {
			tipoTriangulo="equilatero";
		}
		if(this.getLado1()!=this.getLado2() && this.getLado1()!=this.getLado3() && this.getLado2()!=this.getLado3()  ) {
			tipoTriangulo="escaleno";
		}
		if((this.getLado1()==this.getLado2() && this.getLado1()!=this.getLado3()) || (this.getLado1()==this.getLado3() && this.getLado1()!=this.getLado2()) || (this.getLado2()==this.getLado3() && this.getLado2()!=this.getLado1()) ) {
			tipoTriangulo="isósceles";
		}}
		return tipoTriangulo;
		
	}
 }
 
 class Robot{
	 
		/*
		 * 7) En un nuevo proyecto, crear una clase de nombre Robot con los atributos:
		 * batería inicializado en 500 unidades de energía 
		 *  y nombre; 
		 *  un constructor que permita inicializar únicamente a su atributo nombre; los métodos getter y
		 * setter para sus atributos y los siguientes métodos adicionales:
		 * 
		 *  avanzar(): Este método recibirá la cantidad de pasos que deberá dar el
		 * robot, sabiendo que por cada 100 pasos consume 10 unidades de energía y que
		 * sólo avanzará si hay batería suficiente.  bateriaVacia(): Este método
		 * retornará true, sólo cuando la batería quede con un valor menor o igual a
		 * cero. 
		 */
	 private double bateria = 500;
	 public double getBateria() {
		return bateria;
	}

	public void setBateria(double bateria) {
		this.bateria = bateria;
	}

	private String Nombre ;
	 
	 public Robot(String nombre) {
		 this.Nombre=nombre;
		 this.bateria=bateria;
	 }
	 public void avanzar(int pasos) {
		 if (this.getBateria()-(100/10*pasos)<0) {
			 this.setBateria(this.getBateria()-(100/10*pasos));
		 }
		 	System.out.println("No hay suficiente bareria");
	 }
	 
	 public boolean bateriaVacia() {
		 return this.getBateria()<=0;
	 }
 }
 
 class Calculo{
	/*
	 * En un nuevo proyecto, crear una clase de nombre Calculo con los siguientes
	 * métodos estáticos:  esPrimo(): Este método recibe un número entero y retorna
	 * true si el número recibido es primo, caso contrario retornará false. 
	 * valorAbsoluto(): Este método recibe un número entero y retorna su valor
	 * absoluto.  calcularRices(): Este método recibe los coeficientes a, b y c de
	 * una ecuación de segundo grado y mostrará por consola sus raíces y si no las
	 * tiene también lo informará. Luego desde la clase principal del proyecto (la
	 * que contiene el método main) se pide:
	 * 
	 * Utilizando los métodos estáticos de la clase Calculo: a) Informar por consola
	 * si un número escogido por usted es primo o no. b) Mostrar por consola el
	 * valor absoluto del valor -90; c) Mostrar las raíces de la ecuación de segundo
	 * grado con los coeficientes: 1, 0 y 9.
	 */
 }
 
 
 class Fecha{
	/*
	 * 9) En un nuevo proyecto, crear una clase de nombre Fecha con los siguientes
	 * atributos: dia, mes, año; un constructor que permita inicializar a todos sus
	 * atributos; los métodos getter y setter para sus atributos y los siguientes
	 * métodos adicionales:  esBisiesto(): Este método retornará true si el año de
	 * esta Fecha es bisiesto; caso contrario retornará false.  calcularAños():
	 * Este método recibirá un objeto del tipo Fecha y retornará un entero que será
	 * la cantidad de años transcurridos entre esta Fecha y la que recibe por
	 * parámetro. Luego desde la clase principal del proyecto (la que contiene el
	 * método main) se pide: a) Crear dos objetos de tipo fecha. Utilizando sus
	 * métodos: b) Mostrar por consola si la primera fecha y la segunda corresponden
	 * a años bisiestos. c) Mostrar por consola, la cantidad de años transcurridos
	 * entre la primera fecha y la segunda.
	 */
 }
 
 class Pensador{
	/*
	 * 10) En un nuevo proyecto, crear una clase de nombre Pensador con un atributo
	 * que almacenará un valor entero; un constructor que permita inicializar dicho
	 * atributo; los métodos get y set para dicho atributo y los siguientes métodos
	 * adicionales:
	 * 
	 *  invertir(): Este método retornará el valor guardado en el atributo con sus
	 * cifras invertidas. Por ejemplo si el valor guardado es 3915, retornará 5193 
	 * parAntes(): Este método retornará el valor par próximo anterior al valor
	 * guardado.
	 * 
	 *  parPosterior(): Este método retornará el valor par próximo posterior al
	 * valor guardado.  primerDigito(): Este método retornará el primer dígito del
	 * valor guardado.  ultimoDigito(): Este método retornará el último dígito del
	 * valor guardado. Luego desde la clase principal del proyecto (la que contiene
	 * el método main) se pide: a) Crear una instancia de la clase Pensador. b)
	 * Probar todos sus métodos y mostrar por consola los resultados obtenidos.
	 */
	 
 }
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-10 01:24:10.734
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-10 01:24:10.735
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2391)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3069)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-04-10 14:39:27.243 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=20
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_MX
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-10 14:39:28.002
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-10 14:39:39.283
!MESSAGE Logback config file: C:\Users\sr.sergiio\OneDrive\Documentos\ArgentinaPrograma\Workspace - Java ArgPrograma\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-10 14:39:40.395
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-10 14:39:40.395
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-10 14:39:40.395
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-10 14:39:42.979
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sr.sergiio'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-10 15:50:42.947 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=20
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_MX
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-10 15:50:44.112
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-10 15:50:59.114
!MESSAGE Logback config file: C:\Users\sr.sergiio\OneDrive\Documentos\ArgentinaPrograma\Workspace - Java ArgPrograma\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-10 15:51:00.702
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-10 15:51:00.702
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-10 15:51:00.702
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-10 15:51:04.314
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sr.sergiio'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
